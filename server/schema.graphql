type Query {
  job(id: ID!): Job
  jobs: [Job!] #because makes no sense to have an array with null elements
  company(companyId: ID!): Company
}

type Mutation {
  createJob(input: CreateJobInput!): Job #all mutations should return something.
  # probably mock database is the one who actually returns that job after creating it. cause i don't see any logic for that in our resolver

  
  deleteJob(id:ID!):Job

  updateJob(input:updateJobInput!):Job
}

type Job {
  id: ID! #means mandatory
  title: String!
  description: String
  company: Company #this is called object association
}

type Company {
  id: ID!
  name: String!
  description: String
  jobs: [Job!]
}
# "input" objects can only be used as arguments in other types
input CreateJobInput {#order of items are important when quering
  title: String!
  description: String
}


input updateJobInput {
  id:ID!
  title: String!
  description: String
}